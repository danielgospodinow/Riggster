# <p style="text-align: center;"> Ригстър </p>

## <p style="text-align: center;"> Автор </p>
<p style="text-align: center;"> Даниел Веселинов Господинов </p>
<p style="text-align: center;"> Фн: 81531 </p>
<p style="text-align: center;"> СУ, ФМИ, Компютърни науки, трети курс, втора група </p>

## <p style="text-align: center;"> Проектът </p>
<p style="text-align: center;"> 
    Проектът е разработка в областта на компютърните игри. 
</p>

<p style="text-align: center;"> 
    Той представлява онлайн Roguelike RPG игра, предназначена да бъде играна от повече от един играч.
</p>

# <p style="text-align: center;"> Съдържание </p>
## Тема
Темата на проекта е онлайн Multiplayer RPG Roguelike игра, която върви комплект със сървъра, нужен за нейното играене. Играта предоставя стандартни за този тип игри функционалности, като например: събиране на оръжия, колби и магии от съкровищни съндъци, убиване на вражески единици с примитивен изкуствен интелект, онлайн социализиране с други играчи и други неща.

## Теоретично описание на решението на проблема
#### Сървърът
За успешното играене на една онлайн игра за повече от един играчи е нужно сървър, който постоянно да следи за състоянието на играта и да делегира нейното развитие във времето. Сървърът, с помощта на Java 11, нишки, `docker`, е изграден оптимално да поддържа множество клиенти и да държи двустранна комуникационна връзка с клиентите си.
#### Клиентът
Както всяка игра, тя трябва да предоставя графична среда, да умее да обработва клиентския вход (от клавиатура, джойстик, VR уреди и прочие), да умее да работи достатъчно бързо, че да се предостави гладко усещане за игра, да обработва и споделя информация от сървъра и други. Някои аспекти се постигат лесно с помощта на софтуерна рамка за разработка на игри.

## Проектиране и реализация
#### Сървърът
Той се състои от една главна нишка, която се занимава с приемането на нови клиенти и множество (за в момента неограничен брой) помощни нишки, които се занимават с комуникацията с клиентите. В момента, в който нов клиент направи връзка със сървъра, за него се стартира нова нишка, която си обслужва само него. Това е направено, за да се постигне поддръжката на повече от един клиенти. 

<img src="https://i.imgur.com/5wRppI2.png"/>

Понеже всички клиенти достъпват общи ресурви върху съвъра, то повечето функционалности, които сървърът предлага (като например broadcast на съобщение из всички клиенти) са синхронизирани. Сървърът работи със синхронизирани структури от данни. Тези структури от данни съдържат информация за чудовищата по картата (име, позиция, жизнени точки и други), информация за всеки един играч (име, позиция и други) и за съкровищата из картата. Цялата тази информация се зарежда динамично на сървъра при зареждането на избраната карта, на която ще се играе играта. Първоначално, преди да започне самата игра, сървърът изпраща на клиента файловете, които са нужни на клиента да зареди картата, на която се играе играта, след което клиентът събира от сървъра информация за това къде са останалите играчи, къде и на колко живот са противниците, къде се намират съкровищата по картата и дали вече те са използвани от други играчи. Главната цел на сървъра е да съхранява едно единно и консистентно състояние на картата, на която се играе играта, с цел всеки клиент да получава една и съща информация за света. Така всеки играч играе в свят еднакъв с останалите играчи. Сървърът също частично играе роля в мрежовото синхронизиране на чудовищата в играта. Понеже всяко чудовище има примитивен AI (гони играчи, които са твърде близо), то сървърът частично се грижи това чудовище да гони точно и само един човек. В сървъра не са използвани външни библиотеки или софтуерни рамки, всичко е писано на чиста Java. Сървърът работи в класове-модели на обектите, които се синхронизират по мрежата.

#### Клиентът
Клиентът е играта. Клиентът предоставя графичната среда, занимава се с обработката на вход от периферия, занимава се с обновяването на състоянието на играта и с мрежови синхронизации на състоянието на играта. Определен брой пъти в секундата, играта бива обновявана и преначертавана, също, при нужда, някои промени, които са от глобално значение, се изпращат на сървъра, който съобщава на останалите играчи за тези промени в играта.
В началото на играта, играчът бива посрещнат от меню, в което се очаква да се въведе име на играч и IP адрес на сървъра. В случай че играчът въведе IP адрес, на който върви Ригстър сървър, той бива вкаран в света при останалите играчи след кратко събиране на информация за него. В този свят играчът може да се разхожда, да убива чудовища, да събира съкровища и прочие. 
В клиента се използва едно единствено външно нещо- софтуерната рамка `libGDX`. Тя спомага с менежирането на входа от играчите и с графиката и зареждането на картата, изпратена от сървъра.
Клиентът съдържа богата гама от обекти. Архитектурата е сравнително дебела.

* Актрьорите
<p> <img src="https://i.imgur.com/gW1hsYH.png" width="1000px"/> </p>
* Съкровищата
<p> <img src="https://i.imgur.com/boSg7NG.png" width="1000px"/> </p>
* Сцените
<p> <img src="https://i.imgur.com/w1q6YcD.png" width="1000px"/> </p>
* Мрежовият контролер
<p> <img src="https://i.imgur.com/QiQhG5f.png" width="1000px"/> </p>

## Ръководство за инсталация
#### Сървърът
Сървърът е контейниризиран с `docker` и изображението може да бъде намерено тук: <a href="https://hub.docker.com/r/danielgospodinow/riggster-server">Docker hub</a>. Това е направено с цел по-лесно стартирване на произволна машина. Като например, в моя случай, на AWS машина.

Сървърът много лесно може да бъде стартиран през `docker` с командата: `docker run -p 3000:3000 -t danielgospodinow/riggster-server`, която стартира сървъра и свързва порт 3000 на докер контейнера с порт 3000 на машината, на която се стартирва сървтърът.

Освен `docker`, сървърът може да се стартира с командата `java -jar RiggsterServer/out/artifacts/RiggsterServer_jar/RiggsterServer.jar`.

#### Клиентът
Клиентът преди да бъде стартиран, той трябва да бъде изграден ("*build*"-нат).
Преди изграждането трябва да бъде променена стойността на *jdk* полето във файла `packr-YOUR_BUILD_TARGET-config.json`. То трябва да предоставя валиден път към JDK.
След това се изпълняват един от тези скриптове.
* За Windows (64-bit): `cd Riggster && ./build-win64.sh`
* За Linux (64-bit): `cd Riggster && ./build-linux.sh`

След това се търси изпълним файл `Riggster(.exe)` в съответната директория на съответния build.

Другят вариант е с командата `cd Riggster/out/artifacts/Riggster_jar && java -jar desktop_main.jar`. 

#### Демонстрация на клиента с няколко снимки
<img src = "https://i.imgur.com/oDMio5s.png"/>
<img src = "https://i.imgur.com/g0rHvPy.png" width="2000px"/>
<img src = "https://i.imgur.com/MMnkufU.png" width="2000px"/>

## Резултати
#### Клиентът
Макар че има доста още за разработване, тя е абсолютно функционираща игра, която предоставя най-основните неща. Има още доста функционалности, които ще бъдат добавени за вбъдеще, които драстично ще подобрят удоволствието от играенето.
#### Сървърът
В общи линии е завършен. Единствено може да бъде надграждан, за да пасва на новите функционалности на клиента.

## Литература и използвани източници
1) Видео материал в Youtube: <a href="https://www.youtube.com/watch?v=a8MPxzkwBwo&index=1&list=PLZm85UZQLd2SXQzsF-a0-pPF6IWDDdrXt">Super Mario development with libGDX</a>
2) Курсът по Java във ФМИ: <a href="https://github.com/fmi/java-course/">Java съвременни технологии (ФМИ)</a>
3) Курсът по мрежи във ФМИ: <a href="https://learn.fmi.uni-sofia.bg/course/view.php?id=4649">Мрежово програмиране (ФМИ)</a>
4) Документацията на API-то на софтуерната рамка: <a href="https://libgdx.badlogicgames.com/ci/nightlies/docs/api/">libGDX API</a>
5) Класиката: <a href="https://stackoverflow.com/">Stack Overflow</a>

## Приложение
* Линк към проекта в Github: <a href="https://github.com/danielgospodinow/Riggster">Riggster</a>
* Линк към използваната софтуерната рамка за разработка на игри: <a href="https://libgdx.badlogicgames.com/index.html">libGDX</a>
* Линк към програмата, която спомага за генериране на карти: <a href="https://www.mapeditor.org/">TiledMap</a>
* Линк към контейнеризиращия софтуер: <a href="https://www.docker.com/">docker</a>